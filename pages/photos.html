<head>
    <link rel="stylesheet" href="/scripts/secondstyle.css">
    <style>
    /* basic reset */
    * {
      margin: 0;
    }
    
    /* masonry grid styles */
    .grid--masonry {
      display: grid;
      grid-template-columns: repeat(auto-fit, min(20em, 100%));
      grid-template-rows: masonry;
      justify-content: center;
      grid-gap: 0.5em;
      padding: 0.5em;
    }
    .grid--masonry > * {
      align-self: start;
    }
    .grid--masonry > :first-child {
      grid-column: 1/-1;
      max-height: 0vh;
    }
    
    img {
      display: block;
      width: 100%;
      max-height: inherit;
      object-fit: cover;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
      cursor: pointer;
    }
    </style></head>
    
    <body>
    <section class="grid--masonry">
        <a><img src=""/></a>
        <a><img class="image" src="../images/photos/1.jpeg"/></a>
        <a><img class="image" src="../images/photos/2.jpeg"/></a>
        <a><img class="image" src="../images/photos/3.jpeg"/></a> 
    </section>
    
    <script src="../scripts/babel-6.26.0.min.js"></script>
    <script type="text/babel">
    let grids = [...document.querySelectorAll('.grid--masonry')];
    
    if(grids.length && getComputedStyle(grids[0]).gridTemplateRows !== 'masonry') {
        grids = grids.map(grid => ({
            _el: grid, 
            gap: parseFloat(getComputedStyle(grid).gridRowGap), 
            items: [...grid.childNodes].filter(c => c.nodeType === 1 && +getComputedStyle(c).gridColumnEnd !== -1), 
            ncol: 0
        }));
    
        function layout() {
            grids.forEach(grid => {
                /* get the post relayout number of columns */
                let ncol = getComputedStyle(grid._el).gridTemplateColumns.split(' ').length;
    
                /* if the number of columns has changed */
                if(grid.ncol !== ncol) {
                    /* update number of columns */
                    grid.ncol = ncol;
    
                    /* revert to initial positioning, no margin */
                    grid.items.forEach(c => c.style.removeProperty('margin-top'));
    
                    /* if we have more than one column */
                    if(grid.ncol > 1) {
                        grid.items.slice(ncol).forEach((c, i) => {
                            let prev_fin = grid.items[i].getBoundingClientRect().bottom /* bottom edge of item above */, 
                                    curr_ini = c.getBoundingClientRect().top /* top edge of current item */;
                            
                            c.style.marginTop = `${prev_fin + grid.gap - curr_ini}px`
                        })
                    }
                }
            })
        }
    
        addEventListener('load', e => {
            layout(); /* initial load */
            addEventListener('resize', layout, false) /* on resize */
        }, false);
    }
    
    var images = document.querySelectorAll('.image');
        images.forEach(function(element) {
            element.addEventListener("click",function(){
                window.open(element.src, '_blank');
            });
        });
    </script>
    </body>